## **java知识：GC**

### 1、对象被判定为垃圾的标准

- 没有被其他对象引用

### 2、判定对象是否为垃圾的算法

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\1560331184534.png"  style="zoom:50%">

#### （1）引用计数算法

> - 通过判断对象的引用数量来决定对象是否可以被回收；
> - 每个对象实例都有一个引用计数器，被引用+1，引用失效-1；
> - 任何时候计数器为 0 的对象可以被当作垃圾收集。
>
> <Font color="red">**优点**</Font>：执行效率高，程序执行受影响较小。（垃圾回收时，可以做到几乎不打断程序的执行）
>
> <Font color="blue">**缺点**</font>：无法检测出**循环引用**的情况，导致内存泄漏，如下图：
>
> <img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\1560331751145.png"  style="zoom:50%">
>
> <img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\1560331732095.png"  style="zoom:50%">

#### （2）可达性分析算法

​		通过判断对象的引用链是否可达来决定对象是否可以被回收。这个算法的基本思想就是通过一系列的称为 **“GC Roots”** 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的。

![img](https://camo.githubusercontent.com/6c6a9c7e2a7849cab8d5966ec1916115380e2842/687474703a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d382d32372f37323736323034392e6a7067)

​    **可以作为GC Root的对象：**

- 虚拟机栈中引用的对象（栈帧中的本地变量表）
- 方法区中的常量引用的对象
- 方法区中的类静态属性引用的对象
- 本地方法栈中JNI（Native方法）的引用对象
- 活跃线程的引用对象

### 3、谈谈你了解的垃圾回收算法

#### （1）标记-清除算法

​		标记：从根集合进行扫描，对存活的对象进行标记。

​		清楚：对堆内存从头到尾进行线性便利，回收不可达对象内存。

​		算法分为“标记”和“清除”阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。它是最基础的收集算法，效率也很高，但是会带来两个明显的问题：

1. **效率问题**
2. **空间问题（标记清除后会产生大量不连续的碎片）**

![1560504902730](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\1560504902730.png)

#### （2）复制算法

​		为了解决效率问题，“复制”收集算法出现了。它可以将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。

![1560505084505](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\1560505084505.png)

#### （3）标记-整理算法

​		根据老年代的特点特出的一种标记算法，<font color="red">标记过程仍然与“标记-清除”算法一样</font>，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。

- 避免内存的不连续行
- 不用设置两块内存互换
- 适用于存活率高的场景

#### <font color="red">（4）分代收集算法(Generational Collector,GC)</font>

​		当前虚拟机的垃圾收集都采用分代收集算法，这种算法没有什么新的思想，只是根据对象存活周期的不同将内存分为几块。一般将 java 堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。

​	**比如在新生代中，每次收集都会有大量对象死去，所以可以选择复制算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。**

- 垃圾回收算法的组合拳

- 按照对象生命周期的不同划分区域以采用不同的垃圾回收算法

- 提高垃圾回收效率

  > <font color="orange">**延伸面试问题：**</font>
  >
  > 1） HotSpot 为什么要分为新生代和老年代？
  >
  > 答：
  >
  > 
  >
  > 2）对象如何晋升到老年代？
  >
  > 答：1、经历一定Minor次数依然存活的对象；
  >
  > ​		2、Survivor区域中存放不下的对象；
  >
  > ​		3、新生成的大对象（-XX: +PretenuerSizeThreshold）
  >
  > 
  >
  > 3）常用调优参数？
  >
  > 答：
  >
  > ​		-XX: SurvivoRatio : Eden和Survivor的比值，默认8:1
  >
  > ​		-XX: NewRatio：老年代和年轻代内存大小的比例		
  >
  > ​		-XX: MaxTenuringThreshold：对象从年轻代晋升到老年代经过GC次数的最大				阈值

  <img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\1560843679592.png"  style="zoom:35%">

- Eden区

- 两个Survivor区域

  **新生代：尽可能快速地收集掉那些生命周期短的对象**

  **老年代：存放生命周期较长的对象**

​		大多数情况下，对象在新生代中 eden 区分配。当 eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC.下面我们来进行实际测试以下。

在测试之前我们先来看看 **Minor GC 和 Full GC 有什么不同呢？**

- **新生代 GC（Minor GC）**:指发生新生代的的垃圾收集动作，Minor GC 非常频繁，回收速度一般也比较快。
- **老年代 GC（Major GC/Full GC）**:指发生在老年代的 GC，出现了 Major GC 经常会伴随至少一次的 Minor GC（并非绝对），Major GC 的速度一般会比 Minor GC 的慢 10 倍以上。

> 触发full GC的条件：
>
> 1、老年代空间不足；
>
> 2、永久代空间不足；
>
> 3、CMS GC时出现promotion failed，concurrent mode failure；
>
> 4、Minor GC晋升到老年代的平均大小大于老年代的剩余空间；
>
> 5、调用System.gc()；
>
> 6、使用RMI来进行RPC或管理的JDK应用，每小时执行1次Full GC。

**Stop-the-World**

- JVM由于要执行GC而停止了应用程序的执行
- 任何一种GC算法中都会发生
- 多数GC优化通过减少Stop-the-World发生时间来提高程序性能

**Safepoint**

- 在分析过程中对象引用关系不会变化的点
- 产生Safepoint的地方：方法调用；循环跳转；异常跳转等
- 安全点数量应当适中

### 4、常见的垃圾收集器

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\1561277987784.png"  style="zoom:60%">

​		**如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。**

​		虽然我们对各个收集器进行比较，但并非要挑选出一个最好的收集器。因为知道现在为止还没有最好的垃圾收集器出现，更加没有万能的垃圾收集器，**我们能做的就是根据具体应用场景选择适合自己的垃圾收集器**。试想一下：如果有一种四海之内、任何场景下都适用的完美收集器存在，那么我们的 HotSpot 虚拟机就不会实现那么多不同的垃圾收集器了。

- **JVM的运行模式**

  > Server和Client

- **垃圾收集器之间的联系**

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\1561278104547.png"  style="zoom:45%">

#### （1）Serial 收集器（-XX: +UseSerialGC，复制算法）

​		Serial（串行）收集器收集器是最基本、历史最悠久的垃圾收集器了。大家看名字就知道这个收集器是一个单线程收集器了。它的 **“单线程”** 的意义不仅仅意味着它只会使用一条垃圾收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集工作的时候必须暂停其他所有的工作线程（ **"Stop The World"** ），直到它收集结束。

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\1561279143810.png"  style="zoom:60%">

​		**新生代采用复制算法，老年代采用标记-整理算法。**

​		虚拟机的设计者们当然知道 Stop The World 带来的不良用户体验，所以在后续的垃圾收集器设计中停顿时间在不断缩短（仍然还有停顿，寻找最优秀的垃圾收集器的过程仍然在继续）。

​		但是 Serial 收集器有没有优于其他垃圾收集器的地方呢？当然有，它**简单而高效（与其他收集器的单线程相比）**。Serial 收集器由于没有线程交互的开销，自然可以获得很高的单线程收集效率。Serial 收集器对于运行在 Client 模式下的虚拟机来说是个不错的选择。

- 单线程收集，进行垃圾收集时，必须暂停所有工作线程

- 简单高效，Client模式下默认的年轻代收集器

  

#### （2）ParNew收集器（-XX: +UseParNewGC，复制算法）

​		**ParNew 收集器其实就是 Serial 收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和 Serial 收集器完全一样。**

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\1561279327353.png"  style="zoom:60%">

​		**新生代采用复制算法，老年代采用标记-整理算法。**

​		它是许多运行在 Server 模式下的虚拟机的首要选择，除了 Serial 收集器外，只有它能与 CMS 收集器（真正意义上的并发收集器，后面会介绍到）配合工作。

- 多线程收集，其余的行为、特点和Serial收集器一样
- 单核执行效率不如Serial，在多核下执行才有优势

​		**并行和并发概念补充：**

- **并行（Parallel）** ：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。
- **并发（Concurrent）**：指用户线程与垃圾收集线程同时执行（但不一定是并行，可能会交替执行），用户程序在继续运行，而垃圾收集器运行在另一个 CPU 上。

#### （3）Parallel Scavenge 收集器（-XX: +UseParallelGC，复制算法）

```
-XX:+UseParallelGC 

    使用 Parallel 收集器+ 老年代串行

-XX:+UseParallelOldGC

    使用 Parallel 收集器+ 老年代并行
```

​		**Parallel Scavenge 收集器关注点是吞吐量（高效率的利用 CPU）。CMS 等垃圾收集器的关注点更多的是用户线程的停顿时间（提高用户体验）。所谓吞吐量就是 CPU 中用于运行用户代码的时间与 CPU 总消耗时间的比值。** Parallel Scavenge 收集器提供了很多参数供用户找到最合适的停顿时间或最大吞吐量，如果对于收集器运作不太了解的话，手工优化存在的话可以选择把内存管理优化交给虚拟机去完成也是一个不错的选择。

​		**新生代采用复制算法，老年代采用标记-整理算法。**

- 吞吐量=运行用户代码时间/（运行用户代码时间+垃圾收集时间）
- 比起关注用户线程听段时间，更关注系统吞吐量
- 在多核下执行才有优势，Server模式下默认的年轻代收集器

#### （4）Serial Old 收集器（-XX: +UseSerialOldGC，标记-整理算法）

​		**Serial 收集器的老年代版本**，它同样是一个单线程收集器。它主要有两大用途：一种用途是在 JDK1.5 以及以前的版本中与 Parallel Scavenge 收集器搭配使用，另一种用途是作为 CMS 收集器的后备方案。

- 单线程收集，进行垃圾收集时，必须暂停所有工作线程
- 简单高效，Client模式下默认的老年代收集器

#### （5） Parallel Old 收集器（-XX: +UseParallelOldGC，标记-整理算法）

​		**Parallel Scavenge 收集器的老年代版本**。使用多线程和“标记-整理”算法。在注重吞吐量以及 CPU 资源的场合，都可以优先考虑 Parallel Scavenge 收集器和 Parallel Old 收集器。

- 多线程，吞吐量优先

#### （6）CMS 收集器（-XX: +UseConcMarkSweepGC，标记-清除算法）

​		**CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。它而非常符合在注重用户体验的应用上使用。是 HotSpot 虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。**

​		从名字中的**Mark Sweep**这两个词可以看出，CMS 收集器是一种 **“标记-清除”算法**实现的，它的运作过程相比于前面几种垃圾收集器来说更加复杂一些。整个过程分为四个步骤：

- **初始标记：**stop-the-world。暂停所有的其他线程，并记录下直接与 root 相连的对象，速度很快 ；
- **并发标记：** 并发追溯标记，程序不会停顿。同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。
- **并发预处理：**查找执行并发表及阶段从年轻代晋升到老年代的对象。
- **重新标记：** 暂停虚拟机，扫描CMS堆中的剩余对象。重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短
- **并发清除：** 开启用户线程，同时 GC 线程开始对为标记的区域做清扫。

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\1561518241189.png"  style="zoom:60%">

​		从它的名字就可以看出它是一款优秀的垃圾收集器，主要优点：**并发收集、低停顿**。但是它有下面三个明显的缺点：

- **对 CPU 资源敏感；**
- **无法处理浮动垃圾；**
- **它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。**

#### （7）Garbage-First收集器（-XX: +UseG1GC，复制+标记-清除算法）

​		**G1 (Garbage-First) 是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足 GC 停顿时间要求的同时,还具备高吞吐量性能特征。**

- **将整个java堆内存划分为多个大小相等的Region**

- **年轻代和老年代不再物理隔离**
- 

​		被视为 JDK1.7 中 HotSpot 虚拟机的一个重要进化特征。它具备一下特点：

- **并行与并发**：G1 能充分利用 CPU、多核环境下的硬件优势，使用多个 CPU（CPU 或者 CPU 核心）来缩短 Stop-The-World 停顿时间。部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 java 程序继续执行。
- **分代收集**：虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但是还是保留了分代的概念。
- **空间整合**：与 CMS 的“标记-清理”算法不同，G1 从整体来看是基于“标记-整理”算法实现的收集器；从局部上来看是基于“复制”算法实现的。
- **可预测的停顿**：这是 G1 相对于 CMS 的另一个大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内。

G1 收集器的运作大致分为以下几个步骤：

- **初始标记**
- **并发标记**
- **最终标记**
- **筛选回收**

**G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region(这也就是它的名字 Garbage-First 的由来)**。这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了 GF 收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）。

### 5、GC常见面试题

#### （1）Object的finalize()方法的作用是什么，与C语言中析构函数的作用是否相同？

- finalize()是Object的protected方法，子类可以覆盖该方法以实现资源清理工作，GC在回收对象之前调用该方法。

- 与析构函数作用不同，析构函数的调用的时机是确定的，而它的调用具有不确定性。
- 将违背引用的对象放置于F-Queue队列。
- 方法执行随时可能被终止
- 给予对象最后一次重生的机会

#### （2）Java中的强引用，软引用，弱引用，虚引用有什么用？

- **强引用**

​        以前我们使用的大部分引用实际上都是强引用，这是使用最普遍的引用。如果一个对象具有强引用，那就类似于**必不可少的生活用品**，垃圾回收器绝不会回收它。当内存空 间不足，Java 虚拟机宁愿抛出 OutOfMemoryError 错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。

> 1. 最普遍的引用：Object object=new Object()
> 2. 抛出OutOfMemoryError终止程序也不会回收具有强引用的对象
> 3. 通过将对象设置成null来弱化引用，使其被回收、

```java
String str=new String("abc");//强引用
```

- **软引用**

​        如果一个对象只具有软引用，那就类似于**可有可无的生活用品**。如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。

​        软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收，JAVA 虚拟机就会把这个软引用加入到与之关联的引用队列中。

> 1. 对象处于有用，但非必需的状态
> 2. 只有当内存空间不足时，GC会回收该引用的对象的内存
> 3. 可以用来实现内存敏感的高速缓存

```java
String str=new String("abc");//强引用
SoftReference<String> softRef=new SoftReference<String>(str);//软引用
```

- **弱引用**

​        如果一个对象只具有弱引用，那就类似于**可有可无的生活用品**。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它 所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。

​        弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java 虚拟机就会把这个弱引用加入到与之关联的引用队列中。

> 1. 非必需的对象，比软引用更弱一些
> 2. GC时会被回收
> 3. 被回收的概率也不大，因为GC线程的优先级比较低
> 4. 适用于引用偶尔被使用且不影响垃圾回收的对象

```java
String str=new String("abc");//强引用
WeakReference<String> abcWeakRef= new WeakReference<String>(str);//软引用
```

- **虚引用**

​         "虚引用"顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。

​        **虚引用主要用来跟踪对象被垃圾回收的活动**。

​        **虚引用与软引用和弱引用的一个区别在于：** 虚引用必须和引用队列（ReferenceQueue）联合使用。当垃 圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是 否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。

​        特别注意，在程序设计中一般很少使用弱引用与虚引用，使用软引用的情况较多，这是因为**软引用可以加速 JVM 对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出（OutOfMemory）等问题的产生**。

> 1. 不会决定对象的生命周期
> 2. 任何时候都可能被垃圾收集器回收
> 3. 很总对象被垃圾收集器回收的活动，起哨兵作用
> 4. 必须和引用队列（ReferenceQueue）联合使用

```java
ReferenceQueue queue=new ReferenceQueue();
PhantomReference ref=new PhantomReference(str,queue);
```

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\1561626669063.png"  style="zoom:50%">

- **引用队列**

> 1. 无实际存储结构，存储逻辑依赖于内部节点之间的关系来表达
> 2. 存储关联的且被GC的软引用，弱引用以及虚引用